<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Frogger Infinite Bidirezionale / Apple ][ Cricketeer Clone</title>
  <style>
    body {
      background: #111;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
	  overflow: hidden;
    }
    canvas {
      border: 2px solid #333;
	  background: #383;
	  flex-grow: 1;
	  max-height: 100%;
      max-width: 100%;
    }
	
	#scanlines-overlay {
	  display:none;
	  position: absolute;
	  top: 0;
	  left: 0;
	  right: 0;
	  bottom: 0;
	  pointer-events: none;
	  background: repeating-linear-gradient(
		transparent,
		transparent 0px,
		rgba(0, 0, 0, 0.5) 1px,
		transparent 2px
	  );
	  background-size: 100% 4px;
	  opacity: 1;
	}
  </style>
</head>
<body>
  <div id="scanlines-overlay"></div>
  <canvas id="game" width="400" height="400"></canvas>
  <audio id="cracraSound" preload="auto">
	<source src="./cracra.mp3" type="audio/mpeg">
  </audio>
  <audio id="horn1Sound" preload="auto">
	<source src="./horn1.mp3" type="audio/mpeg">
  </audio>
  <audio id="horn2Sound" preload="auto">
	<source src="./horn2.mp3" type="audio/mpeg">
  </audio>
  <audio id="policeSound" preload="auto">
	<source src="./police.mp3" type="audio/mpeg">
  </audio>
  <audio id="flashSound" preload="auto">
	<source src="./flash.mp3" type="audio/mpeg">
  </audio>
  <audio id="falconSound" preload="auto">
	<source src="./falcon.mp3" type="audio/mpeg">
  </audio>
  <audio id="cricketeerSound" preload="auto">
	<source src="./cricketeer.mp3" type="audio/mpeg">
  </audio>
  <audio id="cricketeerTrafficSound" preload="auto">
	<source src="./cricketeer-traffic.mp3" type="audio/mpeg">
  </audio>
  <script>
  (() => {
    const COLORS = {
	  greenGrassLight:'#383', greenGrassDark:'#262', //erba
	  blueRiverLight:'#27c', blueRiverDark:'#05a', //fiume
	  greenLeafLight:'#383', greenLeafDark:'#161', //foglie
	  daisyCenterLight:'#fb2', daisyCenterBorder:'#f80', //margherita
	  white:'#fff', 
	  black:'#000',
	  gray: '#ddd',
	  brownTutleDark:'#642', brownTurleLight:'#753', brownTurtleBorder:'#420',
	  greenTurtleDark:'#262', greenTurtleLight:'#7a6', greenTurleBorder:'#141',
	  
	  yellowCart:'#fe4',//giallo cartello
	  redCart:'#d22',//rosso cartello
	  blueCart:'#16c',//blu cartello
	  
	  orangeCart:'#f80',//arancione cartello + autovelox
	  grayPole:'#777',//palo
	  grayTarmacLight:'#666', grayTarmacDark:'#444',//asfalto
	  grayWheels:'#111', grayRims:'#888',//ruote auto
	  carsBwLights:'#900', carsFwLights:'#ff9',//luci auto
	  carsBwLightsOn:'#f00', carsFwLightsOn:'#fff',//luci auto
	  trafficLightRed:'#f00', trafficLightYellow:'#ff0', trafficLightGreen:'#0f0',
	  trafficLightRedOff:'#400', trafficLightYellowOff:'#440', trafficLightGreenOff:'#040',
	  policeBlueLightOn: '#00f', policeBlueLightOff: '#004',
	  policeRedLightOn: '#f00', policeRedLightOff: '#400',
	  shadow:'rgba(0,0,0,0.1)', shadowDark:'rgba(0,0,0,0.2)', shadowLight:'rgba(0,0,0,0.05)', shadowNone:'rgba(0,0,0,0)'
	};
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const tile = 40;
    const cols = 10;
    const visibleRows = 10;//Math.ceil(canvas.height / tile) + 2;
    const extraRows = 2;
    
    let frog = { x: 5, y: 0 }; // rana sempre centrata a y=0
    let segments = new Map(); // mappa: y → riga
    
	let offset = 0;         // posizione attuale della camera
	let targetOffset = 0;   // offset desiderato verso cui ci muoviamo
    
	let godMode = false;
	let isMute = false;
	let apple2Mode = false;
	let scanLinesEnabled = false;
	let bw = true;
	
	let isGameOver = false;
	let signsToDraw = [];//cartelli vanno disegnati DOPO
	
    // Utilità
    const randomInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a;
    const carColors = [
      // colori base originali
      '#e74c3c', '#3498db', '#f1c40f', '#9b59b6', '#1abc9c', '#e67e22',
      
      // nuove tinte vivaci
      '#ff6b6b', '#4ecdc4', '#ffe66d', '#ff9f43', '#5f27cd', '#10ac84',
      
      // colori pastello
      '#a29bfe', '#fd79a8', '#81ecec', '#fab1a0', '#74b9ff',
      
      // colori realistici per auto
      '#c0c0c0', // argento
      '#2c3e50', // blu notte
      '#1e272e', // antracite
      '#f5f6fa', // bianco
      '#d63031', // rosso vivo
      '#ffb142', // giallo caldo
      '#16a085', // verde scuro
      '#3867d6', // blu elettrico
      '#b71540', // bordeaux
      '#8e44ad', // viola scuro
    ];

    const randomCarColor = () => carColors[randomInt(0, carColors.length-1)];


    // --- Generazione righe ---
    function generateRow(y) {
      if (segments.has(y)) return; // già esistente
   
      let countGrass = 0;
	  let countRiver = 0;
	  let countRoad = 0;
	  let countDouble = 0;
	  let countTot = 0;
	  for (const [y, row] of segments) {
	    countGrass = countGrass + (row.type === "grass" ? 1 : 0);
		countRoad = countRoad + (row.type === "road" && !row.lane ? 1 : 0);
		countDouble = countDouble + (row.type === "road" && row.lane ? 1 : 0);
		countRiver = countRiver + (row.type === "river" ? 1 : 0);
		countTot++;
      }
	  console.log('grass='+countGrass+' road='+countRoad+' double='+countDouble+ ' river='+countRiver);
	  
	  let apple2CarType1 = y%4 === 0 ? "ferrari" : y%4 === 3 ? "elegant" : y%4 === 2 ? "tir" : "furgo";
	  let apple2CarType2 = y%4 === 1 ? "ferrari" : y%4 === 2 ? "elegant" : y%4 === 3 ? "tir" : "furgo";
	  
      //strada doppia
      const makeDoubleRoad = y !== 0 && (countDouble<3 || countGrass>countTot/2);//Math.random() < 0.25 && (countGrass - countRoad) > 1;
      if (makeDoubleRoad) {
        // Evita di creare doppia se la successiva esiste già
        if (!segments.has(y + 1)) {
		
          let workInProgress = Math.random() < 0.3;
		  let cart = 0;
		  let cartType = 0;
		  if (Math.random() < 0.5) {
		    cart = (1 + ((Math.random() * 10) | 0 )) * tile;//posizione
		    cartType = 1 + ((Math.random() * 8) | 0);
		  }
          var rowA = { y: y, type: "road", lane: 1, cars: [], zebra: 0, workInProgress: workInProgress, cart: cart, cartType: cartType };
          var speedA = 1 + Math.random() * 1.5;
          for (var j = 0; j < 2; j++) {
            var c = {
              x: (j * 5 + randomInt(0, 2)) * tile,
              y: y * tile,
              speed: speedA,
              color: randomCarColor(),
			  type: apple2Mode ? apple2CarType1 : Math.random() < 0.1 ? "police" : "car"
            };
            rowA.cars.push(c);
          }
          segments.set(y, rowA);
        
          var rowB = { y: y + 1, type: "road", lane: 2, cars: [], zebra: 0, workInProgress: workInProgress, cart: cart, cartType: cartType };
          var speedB = -(1 + Math.random() * 1.5);
          for (var j = 0; j < 2; j++) {
            var c2 = {
              x: (j * 5 + randomInt(0, 2)) * tile,
              y: (y+1) * tile,
              speed: speedB,
              color: randomCarColor(),
			  type: apple2Mode ? apple2CarType2 : "car"
            };
            rowB.cars.push(c2);
          }
          segments.set(y+1, rowB);
          
          console.log('generate '+y+' frog y'+frog.y+ ' ->> double', rowA, rowB);
          return;
        }
        else console.log('collisione');
	  }   
      
	  //strada singola
      const makeRoad = y !== 0 && countGrass>countTot/2;//Math.random() < 0.7 && (countGrass - countRoad) > 0;
      if (makeRoad) {
        const dir = Math.random() < 0.5 ? 1 : -1;
        const speed = dir * (1 + Math.random() * 1.2);
		
		//zebrone
		let zebra = 0;
        let zebraType = 0;
        if (Math.random() < 0.5) {
          zebra = 1 + ((Math.random() * 10) | 0 ) * tile;//posizione
          zebraType = (Math.random() * 4) | 0;//tipo strisce
        }
		
		//giallo
		let workInProgress = Math.random() < 0.3;
		
		//cartelli
		let cart = 0;
		let cartType = 0;
		if (Math.random() < 0.5) {
		  cart = zebra ? zebra - dir : (1 + ((Math.random() * 9) | 0 )) * tile - (dir * tile);//posizione
		  cartType = 1 + ((Math.random() * 8) | 0);
		}
		
        const row = { type: 'road', lane: 0, cars: [], zebra: zebra, zebraType: zebraType, workInProgress: workInProgress, cart: cart, cartType: cartType };
		
        for (let j=0;j<3;j++){
          row.cars.push({
            x: (j * 3 + randomInt(0,1)) * tile,
            y: y*tile,
            speed: speed, 
            color: randomCarColor(),
			type: apple2Mode ? apple2CarType1 : "car"
          });
        }
        segments.set(y,row);
        console.log('generate '+y+' frog y'+frog.y+ ' ->> road', row);
        return;
      }
      
	  //fiume
	  const makeRiver = y !== 0 && countRiver ==0 || Math.random() < 0.1;
	  if (makeRiver) {
	    const dir = Math.random() < 0.5 ? 1 : -1;
        const speed = dir * 0.2;
		const row = { type: 'river', woods: []};
		for (let j=0;j<4;j++) {
		  row.woods.push({
		    x : (j * 3 + randomInt(0,1)) * tile,
			y : y * tile,
			speed : speed,
			type : j % 3 === 0 ? "turtle" : j % 3 === 1 ? "daisy" : "leaf"
		  });
		}
		segments.set(y,row);
		console.log('generate '+y+' frog y'+frog.y+ ' ->> river', row);
		return;
	  }
	  
      //erba
	  let hasLake = false;
      let lake = 0;
	  //evita laghi attaccati
	  let menoUno = segments.get(y-1) && segments.get(y-1).hasLake;
	  let piuUno = segments.get(y+1) && segments.get(y+1).hasLake;
	  
      if (Math.random() < 0.1 && !menoUno && !piuUno) {
	      lake = apple2Mode ? 0 : (1 + ((Math.random() * 10) | 0 )) * tile;//posizione
          hasLake = true;//tipo strisce
        }
	  const row = { type:'grass', cars:[], hasLake: hasLake, lake: lake };
	  if (Math.random()<0.1) {
	    //const dir = Math.random() < 0.5 ? 1 : -1;
        const speed = (2 + Math.random() * 3);
	    row.cars.push({
            x: 0,
            y: y*tile,
            speed: speed, 
            color: randomCarColor(),
			type: "falcon"
          });
	  }
      segments.set(y,row);
      console.log('generate '+y+' frog y'+frog.y+ ' ->> grass', row);
    }

    // Inizializza righe visibili
	function initRows() {
      for (let i = visibleRows / 2; i > -visibleRows / 2; i--) {
        generateRow(i);
      }
	}
	
	
	//controlli tastiera
    window.addEventListener('keydown', e=>{
      if (e.keyCode === 37 && frog.x>0) { frog.x--; playSound(apple2Mode ? 'cricketeerSound' : 'cracraSound'); }
      if (e.keyCode === 39 && frog.x<cols-1) { frog.x++; playSound(apple2Mode ? 'cricketeerSound' : 'cracraSound'); }
	  if (e.keyCode === 38) { // su
        targetOffset++;
		generateRow(Math.floor(targetOffset + visibleRows/2));
		//offset++;
        //generateRow(offset + visibleRows/2);
        pruneRows();
		playSound(apple2Mode ? 'cricketeerSound' : 'cracraSound');
      }
	  if (e.keyCode === 40) { // giù
        targetOffset--;
		generateRow(Math.floor(targetOffset - visibleRows/2));
		//offset--;
        //generateRow(offset - visibleRows/2);
        pruneRows();
		playSound(apple2Mode ? 'cricketeerSound' : 'cracraSound');
      }
	  
	  if (e.keyCode === 77) {
	    //77=M
		isMute = !isMute;
	  }
	  
	  if (e.keyCode === 71) {
	    //71=G
		godMode = !godMode;
	  }
	  
	  if (e.keyCode === 65) {
	    //65=A
		apple2Mode = !apple2Mode;
	  }
	  
	  if (e.keyCode === 83) {
	    //83=S
		changeScanLines();
	  }
	  
	  if (e.keyCode === 82) {
	    //82=R
		reset();
	  }
	  
	  if (e.keyCode === 66) {
	    //66=B
		bw = !bw;
	  }
    });

    // --- Rimuove righe vecchie per non accumulare ---
    function pruneRows() {
      /*for (let y of segments.keys()) {
        if (y < offset - (visibleRows/2 + extraRows) || y > offset + (visibleRows/2 + extraRows)) {
          segments.delete(y);
        }
      }*/
	  const camera = Math.round(targetOffset); // valuta rispetto a dove stiamo andando
      const minY = camera - (visibleRows/2 + extraRows);
      const maxY = camera + (visibleRows/2 + extraRows);
      for (let y of Array.from(segments.keys())) {
        if (y < minY || y > maxY) {
          segments.delete(y);
        }
      }
    }


  //fiume
  function drawRiver(y, row) {
    const screenY = canvas.height / 2 - (y - offset) * tile;

    //sfodo sfumato verde
	var grad = ctx.createLinearGradient(0, screenY, 500, screenY + tile);
    grad.addColorStop(0, COLORS.greenGrassLight); // verde chiaro in alto
    grad.addColorStop(1, COLORS.greenGrassDark); // verde scuro in basso
    ctx.fillStyle = grad;
	ctx.fillRect(0, screenY, canvas.width, tile);
	
	//acqua sfumata
    const gradWater = ctx.createLinearGradient(0, screenY, 0, screenY + tile);
    gradWater.addColorStop(0, COLORS.blueRiverLight);
    gradWater.addColorStop(1, COLORS.blueRiverDark);
    ctx.fillStyle = gradWater;
	
	//bordi ondulati
    const waveHeight = tile / 6;//altezza onda in px
    const waveLength = tile * 2;//distanza onde in px

    ctx.beginPath();

    //bordo alto
    ctx.moveTo(0, screenY);
    for (let x = 0; x <= canvas.width; x += waveLength) {
        ctx.quadraticCurveTo(
            x + waveLength / 2,          // punto di controllo
            screenY + waveHeight,        // picco dell’onda
            x + waveLength,              // punto finale
            screenY                       // ritorno alla linea base
        );
    }

    //bordo basso
    const bottomY = screenY + tile - waveHeight;
    ctx.lineTo(canvas.width, bottomY);
    for (let x = canvas.width; x >= 0; x -= waveLength) {
        ctx.quadraticCurveTo(
            x - waveLength / 2,
            bottomY + waveHeight,        // picco verso il basso
            x - waveLength,
            bottomY
        );
    }

    ctx.closePath();
    ctx.fill();
}
  
  
  
  
  
  //erbetta
  function drawGrass(y, row) {
      var screenY = canvas.height/2 - (y - offset) * tile;

      // Sfondo sfumato
      var grad = ctx.createLinearGradient(0, screenY, 500, screenY + tile);
      grad.addColorStop(0, COLORS.greenGrassLight); // verde chiaro in alto
      grad.addColorStop(1, COLORS.greenGrassDark); // verde scuro in basso
      ctx.fillStyle = grad;
	  ctx.fillRect(0, screenY, canvas.width, tile);
	  
	  // ---- Laghetto
	  if (row.hasLake) {
	    const lakeX = row.lake;
		const lakeY = screenY + tile * 0.10;
		
		if(apple2Mode) return drawApple2House(lakeX, lakeY);

		const rx = tile * 0.5;
		const ry = tile * 0.4;

		const cx = lakeX + rx;
		const cy = lakeY + ry;

		// Bordo irregolare (più vivo)
		ctx.beginPath();
		ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
		ctx.fillStyle = '#26c';
		ctx.fill();

		// Acqua con gradiente più ricco
		const waterGrad = ctx.createRadialGradient(
		  cx, cy, rx * 0.2,
		  cx, cy, rx
		);
		waterGrad.addColorStop(0, '#adf');  // riflesso chiarissimo
		waterGrad.addColorStop(0.5, '#5bf'); // azzurro brillante
		waterGrad.addColorStop(1, '#27d');   // blu profondo

		ctx.beginPath();
		ctx.ellipse(cx, cy, rx * 0.9, ry * 0.9, 0, 0, Math.PI * 2);
		ctx.fillStyle = waterGrad;
		ctx.fill();

		// ---- Riflesso diagonale (tipo highlight) ----
		ctx.save();
		ctx.beginPath();
		ctx.ellipse(cx, cy, rx * 0.9, ry * 0.9, 0, 0, Math.PI * 2);
		ctx.clip();

		const reflGrad = ctx.createLinearGradient(cx - rx, cy - ry, cx + rx, cy + ry);
		reflGrad.addColorStop(0, 'rgba(255,255,255,0.25)');
		reflGrad.addColorStop(0.4, 'rgba(255,255,255,0.05)');
		reflGrad.addColorStop(1, 'rgba(255,255,255,0)');
		ctx.fillStyle = reflGrad;
		ctx.fillRect(cx - rx, cy - ry, rx * 2, ry * 2);
		ctx.restore();

		// ---- Onde leggere ----
		ctx.strokeStyle = 'rgba(255,255,255,0.1)';
		ctx.lineWidth = 1;
		ctx.beginPath();
		ctx.ellipse(cx, cy, rx * 0.7, ry * 0.7, 0, 0, Math.PI * 2);
		ctx.stroke();

		ctx.beginPath();
		ctx.ellipse(cx, cy, rx * 0.45, ry * 0.45, 0, 0, Math.PI * 2);
		ctx.stroke();
		
		
		//squaletto
		const seconds = new Date().getSeconds() % 10;
        ctx.beginPath();
		ctx.moveTo(cx-10+seconds, cy - tile/3);
		ctx.lineTo(cx-10+seconds, cy);
		ctx.lineTo(cx-10+seconds + tile/3, cy);
        ctx.arc(cx-10+seconds, cy, tile/3, 3 * Math.PI / 2, 2 * Math.PI);
		ctx.closePath();
		ctx.fillStyle = COLORS.grayTarmacDark;
        ctx.fill();
		ctx.fillRect(cx-15+seconds, cy, 20, 1);
		ctx.fillRect(cx-12+seconds, cy+2, 18, 1);
		ctx.fillRect(cx-8+seconds, cy+4, 8, 1);
	  } 
  }
  
  
  
function roundRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
}


    
  //strada
function drawSingleRoad(y, row) {
  if(apple2Mode) playSound('cricketeerTrafficSound', true);

  const screenY = canvas.height/2 - (y - offset)*tile;

  // Asfalto
  ctx.fillStyle = COLORS.grayTarmacLight;
  ctx.fillRect(0, screenY, canvas.width, tile);

  // linee continue giallo ogni 3 righe, altrimenti bianco
  ctx.strokeStyle = row.workInProgress ? COLORS.yellowCart : COLORS.white;
  ctx.fillStyle = row.workInProgress ? COLORS.yellowCart : COLORS.white;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, screenY + 2);
  ctx.lineTo(canvas.width, screenY + 2);
  ctx.moveTo(0, screenY + tile - 2);
  ctx.lineTo(canvas.width, screenY + tile - 2);
  ctx.stroke();
  ctx.lineWidth = 1;
  
  //zebrone!
  if (row.zebra !== 0) {
    const crosswalkX = row.zebra;
    const crosswalkWidth = tile * 1; // larghezza delle strisce
    const stripeHeight = 4;            // altezza di ogni striscia

    for (let i = 0; i < tile / (2 * stripeHeight) ; i++) {
      const sy = screenY + 2 + (i * 2 * stripeHeight);
      
      if(row.zebraType === 0 || row.zebraType === 2) {
        ctx.fillRect(crosswalkX, sy, crosswalkWidth, stripeHeight);
      } else if (row.zebraType === 1 || row.zebraType === 3) {
        ctx.fillRect(crosswalkX, sy, 4, stripeHeight);
        ctx.fillRect(crosswalkX + crosswalkWidth - 4, sy, 4, stripeHeight);
      } 
    }
  }
  //i cartelli vanno disegnati DOPO
  if (row.cartType === 1) {
    signsToDraw.push({ type: "speed", x: row.cart - 25, y: screenY + 2 });
  } else if (row.cartType === 2) {
    signsToDraw.push({ type: "cross", x: row.cart - 25, y: screenY + 2 });
  } else if (row.cartType === 3) {
    signsToDraw.push({ type: "slow", x: row.cart - 25, y: screenY + 2 });
  } else if (row.cartType === 4) {
    signsToDraw.push({ type: "noovertake", x: row.cart - 25, y: screenY + 2 });
  } else if (row.cartType === 5) {
    signsToDraw.push({ type: "arrow", x: row.cart - 25, y: screenY + 2 });
  } else if (row.cartType === 6) {
    signsToDraw.push({ type: "nostop", x: row.cart - 25, y: screenY + 2 });
  } else if (row.cartType === 7) {
    signsToDraw.push({ type: "autovelox", x: row.cart - 25, y: screenY + 2 });
  } else if (row.cartType === 8) {
    signsToDraw.push({ type: "trafficlight" + (row.workInProgress ? "broken" : ""), x: row.cart - 25, y: screenY + 2 });
  }
}


//autostrada
function drawRoadPair(y1, y2, row1) {

  if(apple2Mode) playSound('cricketeerTrafficSound', true);

  const screenY1 = canvas.height/2 - (y1 - offset) * tile;
  const screenY2 = canvas.height/2 - (y2 - offset) * tile;
  var top = Math.min(screenY1, screenY2);
  var height = tile * 2;
  
  // Sfondo asfalto
  ctx.fillStyle = COLORS.grayTarmacDark;
  ctx.fillRect(0, top, canvas.width, height);

  // Linee bianche continue sopra e sotto
  ctx.strokeStyle = row1.workInProgress ? COLORS.yellowCart : COLORS.white;
  ctx.fillStyle = row1.workInProgress ? COLORS.yellowCart : COLORS.white;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, top + 2);
  ctx.lineTo(canvas.width, top + 2);
  ctx.moveTo(0, top + height - 2);
  ctx.lineTo(canvas.width, top + height - 2);
  ctx.stroke();
  ctx.lineWidth = 1;

  // Linea tratteggiata centrale
  ctx.strokeStyle = row1.workInProgress ? COLORS.yellowCart : COLORS.white;
  ctx.fillStyle = row1.workInProgress ? COLORS.yellowCart : COLORS.white;
  ctx.setLineDash([12, 8]);
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, top + tile);
  ctx.lineTo(canvas.width, top + tile);
  ctx.stroke();
  ctx.lineWidth = 1;
  ctx.setLineDash([]);
  
  //i cartelli vanno disegnati DOPO
  if (row1.cartType === 1) {
    signsToDraw.push({ type: "speed", x: row1.cart - 25, y: screenY1 + 2 });
  } else if (row1.cartType === 2 || true) {
    signsToDraw.push({ type: "cross", x: row1.cart - 25, y: screenY1 + 2 });
  } else if (row1.cartType === 3) {
    signsToDraw.push({ type: "slow", x: row1.cart - 25, y: screenY1 + 2 });
  } else if (row1.cartType === 4) {
    signsToDraw.push({ type: "noovertake", x: row1.cart - 25, y: screenY1 + 2 });
  } else if (row1.cartType === 5) {
    signsToDraw.push({ type: "arrow", x: row1.cart - 25, y: screenY1 + 2 });
  } else if (row1.cartType === 6) {
    signsToDraw.push({ type: "nostop", x: row1.cart - 25, y: screenY1 + 2 });
  } else if (row1.cartType === 7) {
    signsToDraw.push({ type: "autovelox", x: row1.cart - 25, y: screenY1 + 2 });
  } else if (row1.cartType === 8) {
    signsToDraw.push({ type: "trafficlight" + (row1.workInProgress ? "broken" : ""), x: row1.cart - 25, y: screenY1 + 2 });
  } 
  
}


//palo dei cartelli stradali
function drawPole(x, y, w, h) {
  //ombra
  ctx.fillStyle = COLORS.shadowDark;
  ctx.beginPath();
  ctx.ellipse(x, y + h, w * 3, w, 0, 0, Math.PI * 2);
  ctx.fill();
  //palo
  ctx.fillStyle = COLORS.grayPole;
  ctx.fillRect(x, y, w, h);
}


function drawCrosswalkSign(x, y) {
  const signWidth = 20;
  const signHeight = 20;
  const poleHeight = 20;

  //palo
  drawPole(x + signWidth / 2 - 1, y + signHeight, 2, poleHeight);
  
  // --- Fondo blu del cartello ---
  ctx.fillStyle = COLORS.blueCart;
  ctx.fillRect(x, y, signWidth, signHeight);

  // --- Triangolo bianco ---
  ctx.beginPath();
  ctx.moveTo(x + signWidth / 2, y + 3);
  ctx.lineTo(x + 3, y + signHeight - 3);
  ctx.lineTo(x + signWidth - 3, y + signHeight - 3);
  ctx.closePath();
  ctx.fillStyle = COLORS.white;
  ctx.fill();

  // --- Omino stilizzato (bianco su blu scuro interno) ---
  const cx = x + signWidth / 2;
  const cy = y + signHeight / 2 + 1;

  // Testa
  ctx.beginPath();
  ctx.arc(cx, cy - 4, 1.5, 0, Math.PI * 2);
  ctx.fillStyle = COLORS.black;
  ctx.fill();

  // Corpo (linea diagonale)
  ctx.strokeStyle = COLORS.black;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(cx, cy - 2);
  ctx.lineTo(cx - 3, cy + 3);
  ctx.lineTo(cx + 3, cy + 3);
  ctx.stroke();

  // Braccia e gambe più visibili
  ctx.beginPath();
  ctx.moveTo(cx - 2, cy - 1);
  ctx.lineTo(cx + 2, cy + 1);
  ctx.moveTo(cx, cy + 3);
  ctx.lineTo(cx, cy + 6);
  ctx.stroke();
}

function drawDirectionSign(x, y) {
  const radius = 10;          // Raggio del cartello
  const poleHeight = 22;      // Altezza del palo
  const cx = x + radius;
  const cy = y + radius;

  //palo
  drawPole(cx, y + radius + 2, 2, poleHeight);

  // --- Cerchio blu ---
  ctx.beginPath();
  ctx.arc(cx, cy, radius, 0, Math.PI * 2);
  ctx.fillStyle = COLORS.blueCart; // blu stile cartello europeo
  ctx.fill();
  ctx.closePath();

  // --- Bordo bianco ---
  ctx.beginPath();
  ctx.arc(cx, cy, radius - 1.5, 0, Math.PI * 2);
  ctx.lineWidth = 2;
  ctx.strokeStyle = COLORS.white;
  ctx.stroke();
  ctx.closePath();

  // --- Freccia bianca verso l'alto ---
  ctx.fillStyle = COLORS.white;
  ctx.beginPath();

  // punta della freccia
  ctx.moveTo(cx, cy - radius + 3);

  // lati obliqui
  ctx.lineTo(cx - 5, cy + 2);
  ctx.lineTo(cx - 2, cy + 2);

  // gambo
  ctx.lineTo(cx - 2, cy + 6);
  ctx.lineTo(cx + 2, cy + 6);

  // lato destro
  ctx.lineTo(cx + 2, cy + 2);
  ctx.lineTo(cx + 5, cy + 2);

  ctx.closePath();
  ctx.fill();
  ctx.lineWidth = 1;
}

function drawNoOvertakingSign(x, y) {
  const radius = 10;
  const poleHeight = 22;
  const cx = x + radius;
  const cy = y + radius;

  //palo
  drawPole(cx -1, cy + radius, 2, poleHeight);

  // --- Cerchio bianco con bordo rosso ---
  ctx.beginPath();
  ctx.arc(cx, cy, radius, 0, Math.PI * 2);
  ctx.fillStyle = COLORS.white;
  ctx.fill();
  ctx.lineWidth = 3;
  ctx.strokeStyle = COLORS.redCart;
  ctx.stroke();
  ctx.lineWidth = 1;

  // ---------------------------------------------------------------------
  //                 AUTO SAGOMATE – STILE CARTELLO REALE
  // ---------------------------------------------------------------------

  // --- Auto rossa (sinistra) ---
  ctx.fillStyle = COLORS.redCart;
  ctx.beginPath();
  ctx.moveTo(cx - 8, cy + 3);   // parafango posteriore
  ctx.lineTo(cx - 8, cy - 1);
  ctx.lineTo(cx - 7, cy - 4);   // tetto inclinato
  ctx.lineTo(cx - 2, cy - 4);
  ctx.lineTo(cx - 1, cy - 1);   // cofano
  ctx.lineTo(cx - 1, cy + 3);
  ctx.closePath();
  ctx.fill();

  // Ruote
  ctx.fillStyle = COLORS.redCart;
  ctx.beginPath();
  ctx.arc(cx - 7, cy + 3, 1.2, 0, Math.PI * 2);
  ctx.arc(cx - 3, cy + 3, 1.2, 0, Math.PI * 2);
  ctx.fill();


  // --- Auto nera (destra) ---
  ctx.fillStyle = COLORS.black;
  ctx.beginPath();
  ctx.moveTo(cx + 1, cy + 3);  // parafango posteriore
  ctx.lineTo(cx + 1, cy - 1);
  ctx.lineTo(cx + 3, cy - 4);  // tetto inclinato
  ctx.lineTo(cx + 8, cy - 4);
  ctx.lineTo(cx + 8, cy - 1);  // cofano
  ctx.lineTo(cx + 8, cy + 3);
  ctx.closePath();
  ctx.fill();

  // Ruote
  ctx.beginPath();
  ctx.arc(cx + 3, cy + 3, 1.2, 0, Math.PI * 2);
  ctx.arc(cx + 7, cy + 3, 1.2, 0, Math.PI * 2);
  ctx.fill();
}

function drawNoStoppingSign(x, y) {
  const radius = 10;
  const cx = x + radius;
  const cy = y + radius;
  const poleHeight = 22;      // Altezza del palo

  //palo
  drawPole(cx -1, cy + radius, 2, poleHeight);

  // Cerchio blu
  ctx.beginPath();
  ctx.arc(cx, cy, radius, 0, Math.PI * 2);
  ctx.fillStyle = COLORS.blueCart;
  ctx.fill();

  // Bordo rosso
  ctx.lineWidth = 3;
  ctx.strokeStyle = COLORS.redCart;
  ctx.stroke();

  // Barra diagonale 1
  ctx.strokeStyle = COLORS.redCart;
  ctx.beginPath();
  ctx.moveTo(cx - radius + 4, cy - radius + 4);
  ctx.lineTo(cx + radius - 4, cy + radius - 4);
  ctx.stroke();

  // Barra diagonale 2
  ctx.beginPath();
  ctx.moveTo(cx - radius + 4, cy + radius - 4);
  ctx.lineTo(cx + radius - 4, cy - radius + 4);
  ctx.stroke();
  ctx.lineWidth = 1;
}


function drawSpeedLimitSign(x, y, limit) {
  const radius = 10;       // Raggio del cartello (diametro 20)
  const poleHeight = 20;   // Altezza del palo

  //palo
  drawPole(x + radius - 1, y + radius * 2, 2, poleHeight);
  
  // --- Cerchio bianco (sfondo del cartello) ---
  ctx.beginPath();
  ctx.arc(x + radius, y + radius, radius, 0, Math.PI * 2);
  ctx.fillStyle = COLORS.white;
  ctx.fill();
  ctx.closePath();

  // --- Bordo rosso ---
  ctx.beginPath();
  ctx.arc(x + radius, y + radius, radius, 0, Math.PI * 2);
  ctx.lineWidth = 3;
  ctx.strokeStyle = COLORS.redCart;
  ctx.stroke();
  ctx.closePath();

  // --- Testo "50" ---
  ctx.fillStyle = COLORS.black;
  ctx.font = 'bold 10px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(limit, x + radius, y+radius);
  ctx.lineWidth = 1;
}


function drawSlowSign(x, y) {
  const signWidth = 20;
  const signHeight = 20;
  const poleHeight = 20;

  //palo
  drawPole(x + signWidth / 2 - 1, y + signHeight, 2, poleHeight);

  // --- Triangolo giallo ---
  ctx.beginPath();
  ctx.lineWidth = 2;
  ctx.strokeStyle = COLORS.redCart;
  ctx.moveTo(x + signWidth / 2, y + 3);
  ctx.lineTo(x + 3, y + signHeight - 3);
  ctx.lineTo(x + signWidth - 3, y + signHeight - 3);
  ctx.closePath();
  ctx.fillStyle = COLORS.yellowCart;
  ctx.fill();
  ctx.stroke();
  ctx.lineWidth = 1;

  // --- Testo "!" ---
  ctx.fillStyle = COLORS.black;
  ctx.font = 'bold 10px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText("!", x + signWidth/2, y+signHeight/2 + 2);
}

function drawAutoveloxColumn(x, y) {
  //cartello
  drawSpeedLimitSign(x + tile, y , 30);
  // Dimensioni base (scalabili)
  const w = 14;     // larghezza colonnina
  const h = 30;     // altezza colonnina
  const panelH = 20; // altezza pannello bianco/nero
  x+=w;
  y+=10;
  const seconds = new Date().getSeconds();
  
  // -------- Colonnina arancione --------
  ctx.fillStyle = COLORS.orangeCart;// arancione autovelox
  ctx.fillRect(x, y, w, h);
  
  ctx.fillStyle = seconds % 8 === 0 ? COLORS.white : COLORS.black;
  ctx.fillRect(x + 2, y + 2, 10, 5);
  if (seconds % 8 === 0) {
	drawGlow(x+7,y+4,20,COLORS.carsFwLights,COLORS.white,1,1,1,1);
	playSound('flashSound');
  }

  // -------- Strisce nere diagonali --------
  ctx.strokeStyle = COLORS.black;
  ctx.fillStyle = COLORS.black;
  ctx.lineWidth = 1;

  ctx.beginPath();
  ctx.moveTo(x + 1, y + 14);
  ctx.lineTo(x + 1, y + 16);
  ctx.lineTo(x + w - 1, y + 12);
  ctx.lineTo(x + w - 1, y + 10);
  ctx.closePath();
  ctx.fill();  
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(x + 1, y + 20);
  ctx.lineTo(x + 1, y + 22);
  ctx.lineTo(x + w - 1, y + 18);
  ctx.lineTo(x + w - 1, y + 16);
  ctx.closePath();
  ctx.fill();  
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(x + 1, y + 26);
  ctx.lineTo(x + 1, y + 28);
  ctx.lineTo(x + w - 1, y + 24);
  ctx.lineTo(x + w - 1, y + 22);
  ctx.closePath();
  ctx.fill();  
  ctx.stroke();
}

function drawTrafficLightBroken(x, y) {
  drawTrafficLight(x, y, true);
}

function drawTrafficLight(x, y, broken = false) {
  const lightWidth = 8;
  const lightHeight = 20;
  const poleHeight = 20;
  const lightRadius = 2;
  const seconds = new Date().getSeconds();

  //palo
  drawPole(x + lightWidth / 2 - 2, y + lightHeight, 4, poleHeight);

  // --- Corpo del semaforo ---
  ctx.fillStyle = COLORS.greenGrassDark;
  ctx.fillRect(x, y, lightWidth, lightHeight);

  // Rosso
  if(seconds % 3 === 0 && !broken) drawGlow(x + lightWidth / 2, y + lightRadius * 2,10,COLORS.trafficLightRedOff,COLORS.trafficLightRed,1,1,1,1);
  ctx.beginPath();
  ctx.fillStyle = seconds % 3 === 0 && !broken ? COLORS.trafficLightRed : COLORS.trafficLightRedOff;
  ctx.arc(x + lightWidth / 2, y + lightRadius * 2, lightRadius * 1.25, 0, Math.PI * 2);
  ctx.fill();
  

  // Giallo
  if(seconds % 3 === 1) drawGlow(x + lightWidth / 2, y + lightRadius * 5,10,COLORS.trafficLightYellowOff,COLORS.trafficLightYellow,1,1,1,1);
  ctx.beginPath();
  ctx.fillStyle = seconds % 3 === 1 ? COLORS.trafficLightYellow : COLORS.trafficLightYellowOff;
  ctx.arc(x + lightWidth / 2, y + lightRadius * 5, lightRadius, 0, Math.PI * 2);
  ctx.fill();
  
  // Verde
  if(seconds % 3 === 2 && !broken) drawGlow(x + lightWidth / 2, y + lightRadius * 8,10,COLORS.trafficLightGreenOff,COLORS.trafficLightGreen,1,1,1,1);
  ctx.beginPath();
  ctx.fillStyle = seconds % 3 === 2 && !broken ? COLORS.trafficLightGreen : COLORS.trafficLightGreenOff;
  ctx.arc(x + lightWidth / 2, y + lightRadius * 8, lightRadius, 0, Math.PI * 2);
  ctx.fill();
}




// --- PATTERN A ROMBI -----------------------------------
function createDiamondPattern(ctx) {
  const pCanvas = document.createElement('canvas');
  const pCtx = pCanvas.getContext('2d');

  const size = 10;      // grandezza del modulo
  pCanvas.width = size;
  pCanvas.height = size;

  // sfondo
  pCtx.fillStyle = COLORS.brownTurleLight;
  pCtx.fillRect(0, 0, size, size);

  // rombi (2 triangoli che formano un rombo)
  pCtx.strokeStyle = COLORS.brownTutleDark;
  pCtx.lineWidth = 1;

  pCtx.beginPath();
  pCtx.moveTo(size / 2, 0);
  pCtx.lineTo(size, size / 2);
  pCtx.lineTo(size / 2, size);
  pCtx.lineTo(0, size / 2);
  pCtx.closePath();
  pCtx.stroke();

  return ctx.createPattern(pCanvas, 'repeat');
}



//disegna le foglie nel fiume
function drawLeaf(c) { 
  const screenY = canvas.height/2 - (c.y/tile - offset)*tile;
  if (screenY < -tile || screenY > canvas.height + tile) return;

  if (apple2Mode) return drawApple2Wood(c);
  
  const w = tile * 1.2;
  const h = tile * 0.7;
  //angolo alto sinistra
  const x = c.x + (tile - w)/2;
  const y = screenY + (tile - h)/2 - 2;
  //centro
  const ccx = x + w/2;
  const ccy = y + h/2;
  
  //ombra intorno
  ctx.fillStyle = COLORS.shadow;
  ctx.beginPath();
  ctx.ellipse(x + w/2, y + h/2, w / 2, h / 2, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.save();
  if(c.type === "daisy") {
	//margherita
	const petalCount = 8;
	const petalLength = tile * 0.25;
	const petalWidth  = tile * 0.08;
	
	for (let i = 0; i < petalCount; i++) {
		const angle = (i / petalCount) * Math.PI * 2;
		const px = ccx + Math.sin(angle) * petalLength;
        const py = ccy - Math.cos(angle) * 3 * petalLength / 5;
		ctx.beginPath();
		ctx.ellipse(
		  px,
		  py, 
		  petalWidth,
		  petalLength,
		  angle,
		  0,
		  Math.PI * 2
		);

		ctx.fillStyle = COLORS.white;
		ctx.fill();
		ctx.lineWidth = w * 0.015;
		ctx.strokeStyle = COLORS.gray;
		ctx.stroke();
	}

	//centro
	ctx.beginPath();
	ctx.arc(ccx, ccy, w * 0.15, 0, Math.PI*2);
	ctx.fillStyle = COLORS.daisyCenterLight;
	ctx.fill();
	ctx.strokeStyle = COLORS.daisyCenterBorder;
	ctx.lineWidth = w * 0.015;
	ctx.stroke();
	ctx.lineWidth = 1;
  
  } else if (c.type === "turtle"){
  //guscio ovale
  ctx.fillStyle = createDiamondPattern(ctx);
  ctx.strokeStyle = COLORS.brownTurtleBorder;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.ellipse(ccx, ccy, w*0.4, h*0.38, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.stroke();
  

  //testa
  const headW = w * 0.15;
  const headH = w * 0.1
  const direction = c.speed < 0 ? 1 : -1;
  
  ctx.fillStyle = COLORS.greenTurtleLight;
  ctx.strokeStyle = COLORS.greenTurleBorder;
  ctx.beginPath();
  ctx.ellipse(ccx - w*0.38*direction, ccy, headW, headH, 0, direction > 0 ? Math.PI / 2 : 3 * Math.PI / 2, direction > 0 ? 3 * Math.PI / 2 : Math.PI / 2);
  ctx.moveTo(ccx - w*0.38*direction, ccy-headH);
  ctx.lineTo(ccx - w*0.38*direction, ccy+headH);
  ctx.fill();
  ctx.stroke();

  //occhi
  ctx.fillStyle = COLORS.greenTurtleDark;
  ctx.beginPath();
  ctx.arc(ccx - w*0.50*direction, ccy - h*0.06, w*0.022, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(ccx - w*0.50*direction, ccy + h*0.06, w*0.022, 0, Math.PI*2);
  ctx.fill();

  //rana disegnata sempre ad y = canvas.height / 2 -> a me basta che screenY-canvas.height/2 sia zero
  if(Math.abs(c.x/tile - frog.x) < 0.5 && Math.abs(screenY - canvas.height/2) < 0.5) {
    //rana sul groppone
	ctx.fillStyle = COLORS.white;
    ctx.font = '16px sans-serif';
	ctx.textAlign = 'center';
	ctx.fillText('?', ccx - w * 0.7 * direction, ccy - 5);
  }

  //zampe
  ctx.fillStyle = COLORS.greenTurtleLight;
  ctx.strokeStyle = COLORS.greenTurleBorder;

  function leg(vertices) {
    ctx.beginPath();
    ctx.moveTo(vertices[0].x, vertices[0].y);
    vertices.slice(1).forEach(v => ctx.lineTo(v.x, v.y));
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }

  const legW = w * 0.22;
  const legH = h * 0.30;

  //anteriore superiore sinistra
  leg([
    {x: ccx - w*0.37, y: ccy - h*0.23},
    {x: ccx - w*0.50, y: ccy - h*0.40},
    {x: ccx - w*0.25, y: ccy - h*0.33},
  ]);

  //anteriore inferiore sinistra
  leg([
    {x: ccx - w*0.37, y: ccy + h*0.23},
    {x: ccx - w*0.50, y: ccy + h*0.40},
    {x: ccx - w*0.25, y: ccy + h*0.33},
  ]);

  //posteriore superiore destra
  leg([
    {x: ccx + w*0.37, y: ccy - h*0.23},
    {x: ccx + w*0.50, y: ccy - h*0.40},
    {x: ccx + w*0.25, y: ccy - h*0.33},
  ]);

  //posteriore inferiore destra
  leg([
    {x: ccx + w*0.37, y: ccy + h*0.23},
    {x: ccx + w*0.50, y: ccy + h*0.40},
    {x: ccx + w*0.25, y: ccy + h*0.33},
  ]);

  //coda
  ctx.beginPath();
  ctx.moveTo(ccx + w*0.60*direction, ccy);
  ctx.lineTo(ccx + w*0.40*direction, ccy - h*0.1);
  ctx.lineTo(ccx + w*0.40*direction, ccy + h*0.1);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();


  
  } else {
	//fogliona da palude
	ctx.fillStyle = COLORS.greenLeafLight;
    ctx.beginPath();
    ctx.ellipse(x + w/2 - 2, y + h/2 - 2, w / 2 - 2, h / 2 - 2, 0, 0, Math.PI * 2);
    ctx.fill();
  
    //taglio
    ctx.beginPath();
    ctx.strokeStyle = COLORS.greenLeafDark;
    ctx.lineWidth = w / 30;
    ctx.moveTo(ccx, ccy);
    ctx.lineTo(ccx + (c.speed > 0 ? w/3 : -w/3), ccy + h/4);
    ctx.stroke();
    
    //bordo
    ctx.beginPath();
    ctx.strokeStyle = COLORS.greenLeafDark;
    ctx.lineWidth = w / 50;
    ctx.stroke();
	ctx.lineWidth = 1;
  	}

  ctx.restore();
}



//falco
function drawFalcon(c) {
  const screenY = canvas.height/2 - (c.y/tile - offset)*tile;
  if (screenY < -tile || screenY > canvas.height + tile) return;
  const seconds = new Date().getSeconds();

  var w = tile * 0.9;
  var h = tile * 0.6;
  var x = c.x + (tile - w)/2;
  var y = screenY + (tile - h)/2 - 5;

  // Ombra sotto falco
  ctx.fillStyle = COLORS.shadowDark;
  ctx.beginPath();
  ctx.ellipse(x + w/2, y + h + 4, w*0.5, 4, 0, 0, Math.PI*2);
  ctx.fill();
  
    // Gradiente corpo
  const grad = ctx.createLinearGradient(x, y, x + w, y);
  grad.addColorStop(0, COLORS.black);
  grad.addColorStop(1, COLORS.grayTarmacLight);

  ctx.fillStyle = grad;
  ctx.strokeStyle = COLORS.grayTarmacDark;
  ctx.lineWidth = 1;

  //corpo
  ctx.beginPath();
  ctx.moveTo(x + w*0.10, y + h*0.50);     // punta coda stretta
  ctx.lineTo(x + w*0.22, y + h*0.35);     // inizio salita corpo
  ctx.lineTo(x + w*0.45, y + h*0.28);     // dorso
  ctx.lineTo(x + w*0.70, y + h*0.40);     // collo
  ctx.lineTo(x + w*0.88, y + h*0.48);     // testa (piccola)
  ctx.lineTo(x + w*0.70, y + h*0.60);     // collo giù
  ctx.lineTo(x + w*0.45, y + h*0.72);     // ventre stretto
  ctx.lineTo(x + w*0.22, y + h*0.65);     // coda parte bassa
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // Becco
  ctx.fillStyle = COLORS.yellowCart;
  ctx.beginPath();
  ctx.moveTo(x + w*0.90, y + h*0.48);
  ctx.lineTo(x + w*0.98, y + h*0.46);
  ctx.lineTo(x + w*0.90, y + h*0.52);
  ctx.fill();

  // Ala superiore
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.moveTo(x + w*0.33, y + h*0.30);
  ctx.quadraticCurveTo(
    x + w*0.02, y - h*0.55,
    x + w*0.50, y + h*0.25
  );
  ctx.quadraticCurveTo(
    x + w*0.40, y + h*0.33,
    x + w*0.33, y + h*0.30
  );
  ctx.fill();

  // Ala inferiore
  ctx.beginPath();
  ctx.moveTo(x + w*0.33, y + h*0.70);
  ctx.quadraticCurveTo(
    x + w*0.02, y + h*1.55,
    x + w*0.50, y + h*0.75
  );
  ctx.quadraticCurveTo(
    x + w*0.40, y + h*0.66,
    x + w*0.33, y + h*0.70
  );
  ctx.fill();
  
  let sameRow = Math.round(c.y/tile - offset) === 0;
  let collision = !sameRow ? false :
				c.speed > 0 ? (frog.x*tile - c.x) < tile * 3 && (frog.x*tile - c.x) > -1 : 
				(c.x - frog.x*tile) < tile * 3 && (c.x - frog.x*tile) > -1;
  let falconScream = collision && Math.random() < 0.1;
  
  ctx.fillStyle = COLORS.black;
  if(falconScream) {
    ctx.fillStyle = COLORS.redCart;
    playSound('falconSound', false);//
  }
  ctx.beginPath();
  ctx.arc(x + w*0.8, y + h*0.6, 1, 0, Math.PI*2);
  ctx.closePath();
  ctx.fill();
  
  ctx.beginPath();
  ctx.arc(x + w*0.8, y + h*0.6 - 5, 1, 0, Math.PI*2);
  ctx.closePath();
  ctx.fill();
}

//casetta
function drawApple2House(x, y) {
  
  ctx.fillStyle = COLORS.black;
  ctx.strokeStyle = COLORS.white;
  
  //corpo casa
  ctx.fillRect(x + 4, y + 6, 36, 26);
  ctx.strokeRect(x + 4, y + 6, 36, 26);

  //porta
  ctx.fillRect(x + 10, y + 8, 18, 24);
  ctx.strokeRect(x + 10, y + 8, 18, 24);
  
  //finestra
  ctx.fillStyle = COLORS.white;
  ctx.fillRect(x + 30, y + 10, 8, 16);
  ctx.fillStyle = COLORS.black;
  ctx.fillRect(x + 33, y + 10, 2, 16);
  ctx.fillRect(x + 30, y + 18, 8, 2);
  
  //tetto
  ctx.strokeStyle = COLORS.white;
  ctx.fillStyle = COLORS.redCart;
  ctx.beginPath();
  ctx.moveTo(x+4, y+6);
  ctx.lineTo(x+12, y-2);
  ctx.lineTo(x+32, y-2);
  ctx.lineTo(x+40, y+6);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  
  //base erbetta
  ctx.fillStyle = COLORS.greenGrassDark;
  ctx.fillRect(x-2,y+34,44,6); 
  
  if (x < canvas.width) {
    drawApple2Tree(x+40, y, 1);
    drawApple2Tree(x+80, y, 2);
	drawApple2House(x+120, y);
  }
  
}

//alberello
function drawApple2Tree(x, y, type = 2) {
  //tronco
  ctx.fillStyle = COLORS.white;
  ctx.fillRect(x + 18, y + 20, 5, 12); // tronco
  ctx.fillRect(x + 15, y + 32, 2, 4);  // radice sinistra
  ctx.fillRect(x + 15, y + 32, 4, 2);  // radice sinistra
  ctx.fillRect(x + 18, y + 30, 2, 6);  // radice centro
  ctx.fillRect(x + 22, y + 30, 2, 6);  // radice destra

  //chioma
  const size = 32; // larghezza della chioma
  const half = size / 2;
  
  //vertici
  let points = [];
  if(type === 1) points = [
    [x + 4 + half - 6, y - 2],           // alto sinistra
    [x + 4 + half + 6, y - 3],           // alto destra
    [x + 4 + size, y + 4],           // destra alto
    [x + 4 + size, y + 18],          // destra basso
    [x + 4 + half + 6, y + 20],      // basso destra
    [x + 4 + half - 6, y + 19],      // basso sinistra
    [x + 4, y + 12],                 // sinistra basso
    [x + 4, y + 4],                  // sinistra alto
  ];
  if(type === 2) points = [
    [x + 4 + half - 7, y - 3],           // alto sinistra
    [x + 4 + half + 6, y - 3],           // alto destra
    [x + 4 + size, y + 4],           // destra alto
    [x + 4 + size - 2, y + 23],          // destra basso
    [x + 4 + half + 5, y + 20],      // basso destra
    [x + 4 + half - 3, y + 19],      // basso sinistra
    [x + 8, y + 24],                 // sinistra basso
    [x + 6, y + 14],                  // sinistra alto
  ];

  //disegno
  ctx.beginPath();
  ctx.moveTo(points[0][0], points[0][1]);
  for (let i = 1; i < points.length; i++) {
    ctx.lineTo(points[i][0], points[i][1]);
  }
  ctx.closePath();

  ctx.fillStyle = COLORS.greenGrassDark;
  ctx.strokeStyle = COLORS.white;
  ctx.fill();
  ctx.stroke();
  
  //base erbetta
  ctx.fillStyle = COLORS.greenGrassDark;
  ctx.fillRect(x-2,y+34,44,6); 
}

//il furgò di batman!
function drawCarApple2Furgo(c) {
  const screenY = canvas.height/2 - (c.y/tile - offset)*tile;
  if (screenY < -tile || screenY > canvas.height + tile) return;

  const x = c.x;
  const y = screenY;
  const spostamento = 6;

  if(c.speed > 0) {
    //corpo rettangolare bianco
	ctx.beginPath();
    ctx.fillStyle = !bw ? c.color : COLORS.white;
    ctx.strokeStyle = COLORS.black;
    ctx.moveTo(x + 0, y + 0 + spostamento);
	ctx.lineTo(x + 5, y + 0 + spostamento);
	ctx.lineTo(x + 6, y + 2 + spostamento);
	ctx.lineTo(x + 11, y + 2 + spostamento);
	ctx.lineTo(x + 12, y + 4 + spostamento);
	ctx.lineTo(x + 17, y + 4 + spostamento);
	ctx.lineTo(x + 18, y + 6 + spostamento);
	ctx.lineTo(x + 32, y + 6 + spostamento);
	ctx.lineTo(x + 32, y + 4 + spostamento);
	ctx.lineTo(x + 38, y + 4 + spostamento);
	ctx.lineTo(x + 40, y + 6 + spostamento);//paraurti
	ctx.lineTo(x + 40, y + 22 + spostamento);//paraurti
	ctx.lineTo(x + 38, y + 24 + spostamento);
	ctx.lineTo(x + 32, y + 24 + spostamento);
	ctx.lineTo(x + 32, y + 22 + spostamento);
	ctx.lineTo(x + 18, y + 22 + spostamento);
	ctx.lineTo(x + 17, y + 24 + spostamento);
	ctx.lineTo(x + 12, y + 24 + spostamento);
	ctx.lineTo(x + 11, y + 26 + spostamento);
	ctx.lineTo(x + 6, y + 26 + spostamento);
	ctx.lineTo(x + 5, y + 28 + spostamento);
	ctx.lineTo(x + 0, y + 28 + spostamento);
	ctx.lineTo(x + 0, y + 0 + spostamento);
	ctx.closePath();
	ctx.fill();
	ctx.stroke();
	//vetro
	ctx.beginPath();
	ctx.fillStyle = COLORS.black;
	ctx.strokeStyle = COLORS.grayTarmacDark;
	ctx.moveTo(x + 20, y + 8 + spostamento);
	ctx.lineTo(x + 32, y + 12 + spostamento);
	ctx.lineTo(x + 20, y + 12 + spostamento);
	ctx.lineTo(x + 20, y + 8 + spostamento);
	ctx.closePath();
	ctx.fill();
	ctx.stroke();
	ctx.beginPath();
	ctx.moveTo(x + 20, y + 16 + spostamento);
	ctx.lineTo(x + 32, y + 16 + spostamento);
	ctx.lineTo(x + 20, y + 20 + spostamento);
	ctx.lineTo(x + 20, y + 16 + spostamento);
	ctx.closePath();
	ctx.fill();
	ctx.stroke();
  } else {
    //corpo rettangolare bianco
	ctx.beginPath();
	ctx.fillStyle = !bw ? c.color : COLORS.white;
    ctx.strokeStyle = COLORS.black;
    ctx.moveTo(x + 40, y + spostamento);
	ctx.lineTo(x - 5 + 40, y + 0 + spostamento);
	ctx.lineTo(x - 6 + 40, y + 2 + spostamento);
	ctx.lineTo(x - 11 + 40, y + 2 + spostamento);
	ctx.lineTo(x - 12 + 40, y + 4 + spostamento);
	ctx.lineTo(x - 17 + 40, y + 4 + spostamento);
	ctx.lineTo(x - 18 + 40, y + 6 + spostamento);
	ctx.lineTo(x - 32 + 40, y + 6 + spostamento);
	ctx.lineTo(x - 32 + 40, y + 4 + spostamento);
	ctx.lineTo(x - 38 + 40, y + 4 + spostamento);
	ctx.lineTo(x - 40 + 40, y + 6 + spostamento);//paraurti
	ctx.lineTo(x - 40 + 40, y + 22 + spostamento);//paraurti
	ctx.lineTo(x - 38 + 40, y + 24 + spostamento);
	ctx.lineTo(x - 32 + 40, y + 24 + spostamento);
	ctx.lineTo(x - 32 + 40, y + 22 + spostamento);
	ctx.lineTo(x - 18 + 40, y + 22 + spostamento);
	ctx.lineTo(x - 17 + 40, y + 24 + spostamento);
	ctx.lineTo(x - 12 + 40, y + 24 + spostamento);
	ctx.lineTo(x - 11 + 40, y + 26 + spostamento);
	ctx.lineTo(x - 6 + 40, y + 26 + spostamento);
	ctx.lineTo(x - 5 + 40, y + 28 + spostamento);
	ctx.lineTo(x + 40, y + 28 + spostamento);
	ctx.lineTo(x + 40, y + 0 + spostamento);
	ctx.closePath();
	ctx.fill();
	ctx.stroke();
	//vetro
	ctx.beginPath();
	ctx.fillStyle = COLORS.black;
	ctx.strokeStyle = COLORS.grayTarmacDark;
	ctx.moveTo(x - 20 + 40, y + 8 + spostamento);
	ctx.lineTo(x - 32 + 40, y + 12 + spostamento);
	ctx.lineTo(x - 20 + 40, y + 12 + spostamento);
	ctx.lineTo(x - 20 + 40, y + 8 + spostamento);
	ctx.closePath();
	ctx.fill();
	ctx.stroke();
	ctx.beginPath();
	ctx.moveTo(x - 20 + 40, y + 16 + spostamento);
	ctx.lineTo(x - 32 + 40, y + 16 + spostamento);
	ctx.lineTo(x - 20 + 40, y + 20 + spostamento);
	ctx.lineTo(x - 20 + 40, y + 16 + spostamento);
	ctx.closePath();
	ctx.fill();
	ctx.stroke();
  }
}

//tir
function drawCarApple2Tir(c) {
  const screenY = canvas.height / 2 - (c.y / tile - offset) * tile;
  if (screenY < -tile || screenY > canvas.height + tile) return;

  const w = tile * 0.9;
  const h = tile * 0.6;
  const x = c.x + (tile - w) / 2;
  const y = screenY + (tile - h) / 2 - 5;

  //ctx.fillStyle=COLORS.redCart;
  //ctx.fillRect(x,y,tile,tile);

  const carWidth = 60;
  const carHeight = 26;
  const spostamento = 4;

  if(c.speed > 0) {
    //corpo rettangolare bianco
    ctx.fillStyle = !bw ? c.color : COLORS.white;
    ctx.strokeStyle = COLORS.black;
    ctx.fillRect(x-20, y + spostamento, carWidth, carHeight);
    ctx.strokeRect(x-20, y + spostamento, carWidth, carHeight);
	//bordo cabina
	ctx.fillStyle = COLORS.black;
	ctx.fillRect(x + tile - 10, y+spostamento, 2, 4);
	ctx.fillRect(x + tile - 10, y+spostamento+carHeight, 2, -4);
	//tettuccio
	ctx.beginPath();
	ctx.arc(x + tile - 16, y + carHeight / 2 + spostamento, carHeight/2, Math.PI * 1.75, Math.PI * 0.25, false);
    ctx.stroke();
	//puntini
	for (let i=1;i<10;i++) {
		ctx.fillRect(x + tile - 10 - i * 5, y + spostamento + 2, 2, 2);
		ctx.fillRect(x + tile - 10 - i * 5, y + spostamento + carHeight - 4, 2, 2);
	}
	
  } else {
    //corpo rettangolare bianco
	ctx.fillStyle = !bw ? c.color : COLORS.white;
    ctx.strokeStyle = COLORS.black;
    ctx.fillRect(x, y + spostamento, carWidth, carHeight);
    ctx.strokeRect(x, y + spostamento, carWidth, carHeight);
	//bordo cabina
	ctx.fillStyle = COLORS.black;
	ctx.fillRect(x + 10, y+spostamento, 2, 4);
	ctx.fillRect(x + 10, y+spostamento+carHeight, 2, -4);
	//tettuccio
	ctx.beginPath();
    ctx.arc(x + 16, y + carHeight / 2 + spostamento, carHeight/2, Math.PI * 0.75, Math.PI * 1.25, false);
    ctx.stroke();
	//puntini
	for (let i=1;i<10;i++) {
		ctx.fillRect(x + 10 + i * 5, y + spostamento + 2, 2, 2);
		ctx.fillRect(x + 10 + i * 5, y + spostamento + carHeight - 4, 2, 2);
	}
  }
}

//ehi, tu, elegantone...
function drawCarApple2Elegant(c) {
  const screenY = canvas.height / 2 - (c.y / tile - offset) * tile;
  if (screenY < -tile || screenY > canvas.height + tile) return;

  const w = tile * 0.9;
  const h = tile * 0.6;
  const x = c.x + (tile - w) / 2;
  const y = screenY + (tile - h) / 2 - 5;

  //ctx.fillStyle=COLORS.redCart;
  //ctx.fillRect(x,y,tile,tile);


  const carWidth = 40;
  const carHeight = 20;
  const spostamento = 6;

  // Corpo rettangolare bianco
  ctx.fillStyle = !bw ? c.color : COLORS.white;
  ctx.strokeStyle = COLORS.black;
  ctx.fillRect(x, y + 6, carWidth, carHeight);
  ctx.strokeRect(x, y + 6, carWidth, carHeight);

  if(c.speed > 0) {
    //cofano ondulato
    ctx.beginPath();
    ctx.arc(x + carWidth - 4, y + carHeight / 2 + spostamento, 6, Math.PI * 1.5, Math.PI * 0.5, false);
    ctx.fill();
    ctx.stroke();
	
	ctx.fillStyle = COLORS.black;//vetro
    ctx.strokeStyle = COLORS.grayTarmacDark;//bordo
    //parabrezza
    ctx.beginPath();
    ctx.arc(x + 2 * carWidth / 3 - 4, y + carHeight / 2 + spostamento, 8, Math.PI * 1.5, Math.PI * 0.5, false);// arco esterno (da alto a basso)
    ctx.arc(x + 2 * carWidth / 3 - 4, y + carHeight / 2 + spostamento, 6, Math.PI * 0.5, Math.PI * 1.5, true);// arco interno (da basso a alto, inverso)
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
	//lunotto
	ctx.beginPath();
    ctx.arc(x + 2 * carWidth / 5 - 4, y + carHeight / 2 + spostamento, 8, Math.PI * 0.5, Math.PI * 1.5, false);// arco esterno (da alto a basso)
    ctx.arc(x + 2 * carWidth / 5 - 4, y + carHeight / 2 + spostamento, 6, Math.PI * 1.5, Math.PI * 0.5, true);// arco interno (da basso a alto, inverso)
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  } else {
    //cofano dietro ondulato
    ctx.beginPath();
    ctx.arc(x + 4, y + carHeight / 2 + spostamento, 6, Math.PI * 0.5, Math.PI * 1.5, false);
    ctx.fill();
    ctx.stroke();
	
	ctx.fillStyle = COLORS.black;//vetro
    ctx.strokeStyle = COLORS.grayTarmacDark;//bordo
    //parabrezza
    ctx.beginPath();
    ctx.arc(x + 2 * carWidth / 5 + 2, y + carHeight / 2 + spostamento, 8, Math.PI * 0.5, Math.PI * 1.5, false);// arco esterno (da alto a basso)
    ctx.arc(x + 2 * carWidth / 5 + 2, y + carHeight / 2 + spostamento, 6, Math.PI * 1.5, Math.PI * 0.5, true);// arco interno (da basso a alto, inverso)
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
	//lunotto
	ctx.beginPath();
    ctx.arc(x + 2 * carWidth / 3 + 2, y + carHeight / 2 + spostamento, 8, Math.PI * 1.5, Math.PI * 0.5, false);// arco esterno (da alto a basso)
    ctx.arc(x + 2 * carWidth / 3 + 2, y + carHeight / 2 + spostamento, 6, Math.PI * 0.5, Math.PI * 1.5, true);// arco interno (da basso a alto, inverso)
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
	
  }
}

//ferrari
function drawCarApple2Ferrari(c) {
  const screenY = canvas.height/2 - (c.y/tile - offset)*tile;
  if (screenY < -tile || screenY > canvas.height + tile) return;
  const seconds = new Date().getSeconds();

  var w = tile * 0.9;
  var h = tile * 0.6;
  var x = c.x + (tile - w)/2;
  var y = screenY + (tile - h)/2 - 5;
  
  //ctx.fillStyle=COLORS.redCart;
  //ctx.fillRect(x,y,tile,tile);


  //dimensioni
  const wheelWidth = 12;
  const wheelHeight = 6;
  const carWidth = 20;
  const carHeight = 12;
  const spostamento = 4;

  if(c.speed > 0) {
    //ruote dietro
    ctx.fillStyle = COLORS.black;
    ctx.strokeStyle = COLORS.white;
    ctx.fillRect(x, y + spostamento, wheelWidth, wheelHeight);//alto
    ctx.strokeRect(x, y + spostamento, wheelWidth, wheelHeight);
    ctx.fillRect(x, y + spostamento + carHeight + wheelHeight, wheelWidth, wheelHeight);//basso
    ctx.strokeRect(x, y + spostamento + carHeight + wheelHeight, wheelWidth, wheelHeight);
    ctx.fillStyle = COLORS.white;
    ctx.fillRect(x + wheelWidth/2, y + spostamento + wheelHeight, 2, carHeight);//asse
    
    //ruote avanti appena piu strette
    ctx.fillStyle = COLORS.black;
    ctx.strokeStyle = COLORS.white;
    ctx.fillRect(x + carWidth, y + spostamento + 1, wheelWidth, wheelHeight);//alto
    ctx.strokeRect(x + carWidth, y + spostamento + 1, wheelWidth, wheelHeight);
    ctx.fillRect(x + carWidth, y + spostamento + 1 + carHeight + wheelHeight - 2, wheelWidth, wheelHeight);//basso
    ctx.strokeRect(x + carWidth, y + spostamento + 1 + carHeight + wheelHeight - 2, wheelWidth, wheelHeight);
    ctx.fillStyle = COLORS.white;
    ctx.fillRect(x + wheelWidth/2 + carWidth -1, y + spostamento + 1 + wheelHeight, 2, carHeight - 2);//asse
    
	//corpo macchina largo (motorone)
	ctx.fillStyle = !bw ? c.color : COLORS.redCart;
	ctx.strokeStyle = COLORS.white;
	ctx.fillRect(x, y + spostamento + wheelHeight + 2, carWidth, carHeight - 4);
	ctx.strokeRect(x, y + spostamento + wheelHeight + 2, carWidth, carHeight - 4);
	//parte stretta anteriore (muso)
	ctx.fillRect(x + carWidth, y + spostamento + wheelHeight + 4, carWidth / 2 + 2, carHeight - 8);
	ctx.strokeRect(x + carWidth, y + spostamento + wheelHeight + 4, carWidth / 2 + 2, carHeight - 8);
	//punta dietro
	ctx.beginPath();
	ctx.moveTo(x, y + spostamento + wheelHeight + 2);
	ctx.lineTo(x, y + spostamento + wheelHeight + 10);
	ctx.lineTo(x - 4, y + spostamento + wheelHeight + 6);
	ctx.closePath();
	ctx.fill();
	ctx.stroke();
  } else {
    // ruote dietro (lato destro)
    ctx.fillStyle = COLORS.black;
    ctx.strokeStyle = COLORS.white;
    ctx.fillRect(x + w + wheelWidth - carWidth, y + spostamento, wheelWidth, wheelHeight); // alto
    ctx.strokeRect(x + w + wheelWidth - carWidth, y + spostamento, wheelWidth, wheelHeight);
    ctx.fillRect(x + w + wheelWidth - carWidth, y + spostamento + carHeight + wheelHeight, wheelWidth, wheelHeight); // basso
    ctx.strokeRect(x + w + wheelWidth - carWidth, y + spostamento + carHeight + wheelHeight, wheelWidth, wheelHeight);
    ctx.fillStyle = COLORS.white;
    ctx.fillRect(x + w + wheelWidth - carWidth + wheelWidth / 2 - 2, y + spostamento + wheelHeight, 2, carHeight); // asse
    
    // ruote avanti (lato sinistro)
    ctx.fillStyle = COLORS.black;
    ctx.strokeStyle = COLORS.white;
    ctx.fillRect(x + w - carWidth - wheelWidth, y + spostamento + 1, wheelWidth, wheelHeight); // alto
    ctx.strokeRect(x + w - carWidth - wheelWidth, y + spostamento + 1, wheelWidth, wheelHeight);
    ctx.fillRect(x + w - carWidth - wheelWidth, y + spostamento + 1 + carHeight + wheelHeight - 2, wheelWidth, wheelHeight); // basso
    ctx.strokeRect(x + w - carWidth - wheelWidth, y + spostamento + 1 + carHeight + wheelHeight - 2, wheelWidth, wheelHeight);
    ctx.fillStyle = COLORS.white;
    ctx.fillRect(x + w - carWidth - wheelWidth + wheelWidth / 2 - 1, y + spostamento + 1 + wheelHeight, 2, carHeight - 2); // asse
    
    // corpo macchina largo (motorone dietro)
    ctx.fillStyle = !bw ? c.color : COLORS.redCart;
    ctx.strokeStyle = COLORS.white;
    ctx.fillRect(x + w - carWidth, y + spostamento + wheelHeight + 2, carWidth, carHeight - 4);
    ctx.strokeRect(x + w - carWidth, y + spostamento + wheelHeight + 2, carWidth, carHeight - 4);
    
    // parte stretta anteriore (muso sinistro)
    ctx.fillRect(x + w - carWidth - carWidth / 2 - 2, y + spostamento + wheelHeight + 4, carWidth / 2 + 2, carHeight - 8);
    ctx.strokeRect(x + w - carWidth - carWidth / 2 - 2, y + spostamento + wheelHeight + 4, carWidth / 2 + 2, carHeight - 8);
    
    // punta dietro (destra)
    ctx.beginPath();
    ctx.moveTo(x + w, y + spostamento + wheelHeight + 2);
    ctx.lineTo(x + w, y + spostamento + wheelHeight + 10);
    ctx.lineTo(x + w + 4, y + spostamento + wheelHeight + 6);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
}

//tronchi galleggianti
function drawApple2Wood(c) {
  const screenY = canvas.height/2 - (c.y/tile - offset)*tile;
  if (screenY < -tile || screenY > canvas.height + tile) return;

  const x = c.x;
  const y = screenY;
  const spostamento = 8;

  ctx.fillStyle = COLORS.white;
  ctx.strokeStyle = COLORS.black;
  ctx.beginPath();
  ctx.moveTo(x+2, y + spostamento);
  ctx.lineTo(x+38, y + spostamento);
  ctx.lineTo(x+40, y + 2 + spostamento);
  ctx.lineTo(x+40, y + 22 + spostamento);
  ctx.lineTo(x+38, y + 24 + spostamento);
  ctx.lineTo(x+2, y + 24 + spostamento);
  ctx.lineTo(x, y + 22 + spostamento);
  ctx.lineTo(x, y + 2 + spostamento);
  ctx.lineTo(x+2, y +  spostamento);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
}

    
//disegna le automobili
function drawCar(c) {
  let carType = c.type;
  if(carType === "elegant") return drawCarApple2Elegant(c);
  if(carType === "ferrari") return drawCarApple2Ferrari(c);
  if(carType === "tir") return drawCarApple2Tir(c);
  if(carType === "furgo") return drawCarApple2Furgo(c);

  const screenY = canvas.height/2 - (c.y/tile - offset)*tile;
  if (screenY < -tile || screenY > canvas.height + tile) return;
  const seconds = new Date().getSeconds();

  var w = tile * 0.9;
  var h = tile * 0.6;
  var x = c.x + (tile - w)/2;
  var y = screenY + (tile - h)/2 - 5;
  
  // Ombra sotto auto
  ctx.fillStyle = COLORS.shadowDark;
  ctx.beginPath();
  ctx.ellipse(x + w/2, y + h + 4, w*0.5, 4, 0, 0, Math.PI*2);
  ctx.fill();

  // Corpo principale con gradiente
  var grad = ctx.createLinearGradient(x, y, x, y + h);
  grad.addColorStop(0, shadeColor(c.color, +20));
  grad.addColorStop(1, shadeColor(c.color, -20));
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.moveTo(x + w*0.1, y);
  ctx.lineTo(x + w*0.9, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + h*0.3);
  ctx.lineTo(x + w, y + h*0.7);
  ctx.quadraticCurveTo(x + w, y + h, x + w*0.9, y + h);
  ctx.lineTo(x + w*0.1, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h*0.7);
  ctx.lineTo(x, y + h*0.3);
  ctx.quadraticCurveTo(x, y, x + w*0.1, y);
  ctx.fill();

  // Ruote
  var wheelR = h*0.25;
  ctx.fillStyle = COLORS.grayWheels;
  ctx.beginPath();
  ctx.arc(x + w*0.2, y + h + wheelR*0.3, wheelR, 0, Math.PI*2);
  ctx.arc(x + w*0.8, y + h + wheelR*0.3, wheelR, 0, Math.PI*2);
  ctx.fill();

  // Cerchioni
  ctx.fillStyle = COLORS.grayRims;
  ctx.beginPath();
  ctx.arc(x + w*0.2, y + h + wheelR*0.3, wheelR*0.6, 0, Math.PI*2);
  ctx.arc(x + w*0.8, y + h + wheelR*0.3, wheelR*0.6, 0, Math.PI*2);
  ctx.fill();
  
  let sameRow = Math.round(c.y/tile - offset) === 0;
  let collision = !sameRow ? false :
				c.speed > 0 ? (frog.x*tile - c.x) < tile * 3 && (frog.x*tile - c.x) > -1 : 
				(c.x - frog.x*tile) < tile * 3 && (c.x - frog.x*tile) > -1;
  let carLightSound = collision && Math.random() < 0.01;
  
  let isPolice = c.type === "police";
  
  if (c.speed > 0) {
    
	if(carLightSound) {
	  drawGlow(x + w,y+h*0.6+3,20,COLORS.carsFwLights,COLORS.carsFwLightsOn,1,0,0,1);
	  drawGlow(x,y+h*0.6+3,10,COLORS.carsBwLights,COLORS.carsBwLightsOn,0,1,1,0);
	  playSound('horn1Sound');
	}
	//luci
    ctx.fillStyle = collision ? COLORS.carsFwLightsOn : COLORS.carsFwLights;
    ctx.fillRect(x + w - 1, y + h*0.6, 2, 6);
	//stop
	ctx.fillStyle = collision ?  COLORS.carsBwLightsOn : COLORS.carsBwLights;
    ctx.fillRect(x, y + h*0.6, 2, 6);
	
	
	if(isPolice) {
	  // Finestrini / tetto
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.fillRect(x + w * 0.7, y + h*0.15, w * 0.3, h*0.3);
	  if (seconds % 2 === 0) { 
	    drawGlow(x + w / 4, y, 20, COLORS.policeBlueLightOff, COLORS.policeBlueLightOn, 0,0,1,1); 
		ctx.fillStyle = COLORS.policeBlueLightOn;
        ctx.fillRect(x + w / 4 - 2, y - 1, 4, 2);
		ctx.fillStyle = COLORS.policeRedLightOff;
        ctx.fillRect(x + 3 * w / 4 - 2, y - 1, 4, 2);
		}
	  else { 
		drawGlow(x + 3 * w / 4, y, 20, COLORS.policeRedLightOff, COLORS.policeRedLightOn, 0,0,1,1); 
		ctx.fillStyle = COLORS.policeRedLightOn;
        ctx.fillRect(x + 3 * w / 4 - 2, y - 1, 4, 2);
		ctx.fillStyle = COLORS.policeBlueLightOff;
        ctx.fillRect(x + w / 4 - 2, y - 1, 4, 2);
	  }
	  if (seconds % 5 === 0) playSound('policeSound');
	} 
	else {
	  // Finestrini / tetto
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.fillRect(x, y + h*0.15, w * 0.6, h*0.3);
      ctx.fillRect(x + w * 0.7, y + h*0.15, w * 0.3, h*0.3);
	}
  }
  else {
    if(carLightSound) {
	  drawGlow(x,y+h*0.6+3,20,COLORS.carsFwLights,COLORS.carsFwLightsOn,0,1,1,0);
	  drawGlow(x+w,y+h*0.6+3,10,COLORS.carsBwLights,COLORS.carsBwLightsOn,1,0,0,1);
	  playSound('horn2Sound');
	}
    //luci
    ctx.fillStyle = collision ?  COLORS.carsFwLightsOn : COLORS.carsFwLights;
    ctx.fillRect(x, y + h*0.6, 2, 6);
	//stop
	ctx.fillStyle = collision ?  COLORS.carsBwLightsOn : COLORS.carsBwLights;
	ctx.fillRect(x + w - 1, y + h*0.6, 2, 6);
	
	if (isPolice) {
	  // Finestrini / tetto
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.fillRect(x, y + h*0.15, w * 0.3, h*0.3);
	  if (seconds % 2 === 0) { 
	    drawGlow(x + w / 4, y, 20, COLORS.policeBlueLightOff, COLORS.policeBlueLightOn, 0,0,1,1); 
		ctx.fillStyle = COLORS.policeBlueLightOn;
        ctx.fillRect(x + w / 4 - 2, y - 1, 4, 2);
		ctx.fillStyle = COLORS.policeRedLightOff;
        ctx.fillRect(x + 3 * w / 4 - 2, y - 1, 4, 2);
		}
	  else { 
		drawGlow(x + 3 * w / 4, y, 20, COLORS.policeRedLightOff, COLORS.policeRedLightOn, 0,0,1,1); 
		ctx.fillStyle = COLORS.policeRedLightOn;
        ctx.fillRect(x + 3 * w / 4 - 2, y - 1, 4, 2);
		ctx.fillStyle = COLORS.policeBlueLightOff;
        ctx.fillRect(x + w / 4 - 2, y - 1, 4, 2);
	  }
	  if (seconds % 5 === 0) playSound('policeSound');
	} 
	else {
	  // Finestrini / tetto
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.fillRect(x + w * 0.4, y + h*0.15, w * 0.6, h*0.3);
      ctx.fillRect(x, y + h*0.15, w * 0.3, h*0.3);
    }    
  }
}

//utility per effetto luce
function drawGlow(x, y, radius, colorFrom, colorTo, q0, q1, q2, q3) {
  const gradient = ctx.createRadialGradient(
    x, y, 0,
    x, y, radius
  );

  gradient.addColorStop(0, colorFrom);
  gradient.addColorStop(1, hex3ToRgba(colorTo));
  
  ctx.fillStyle = gradient;
  ctx.beginPath(); 
  if(q0) ctx.arc(x, y, radius, Math.PI * 0, Math.PI * 0.5);
  if(q1) ctx.arc(x, y, radius, Math.PI * 0.5, Math.PI);
  if(q2) ctx.arc(x, y, radius, Math.PI, Math.PI * 1.5);
  if(q3) ctx.arc(x, y, radius, Math.PI * 1.5, Math.PI * 2);
  ctx.fill();  
}

function hex3ToRgba(hex) {
  hex = hex.replace('#', '');

  const r = parseInt(hex[0] + hex[0], 16);
  const g = parseInt(hex[1] + hex[1], 16);
  const b = parseInt(hex[2] + hex[2], 16);

  return `rgba(${r}, ${g}, ${b}, 0)`;
}


//utility per ombreggiare colore esadecimale
function shadeColor(color, percent) {
  var f=parseInt(color.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent;
  var R=f>>16, G=f>>8&0x00FF, B=f&0x0000FF;
  var newR=Math.round((t-R)*p/100+R),
      newG=Math.round((t-G)*p/100+G),
      newB=Math.round((t-B)*p/100+B);
  return '#'+(0x1000000 + (newR<<16) + (newG<<8) + newB).toString(16).slice(1);
}


    // --- Update ---
    function update() {
	  //interpolazione morbida dell'offset
	  //offset += (targetOffset - offset) * 0.2;//no va bene, spostamento infinito
	  
	  let step = (targetOffset - offset) * 0.2;
      
      if (Math.abs(step) < 0.05) step = 0.05 * Math.sign(step);//step minimo
      
	  if (Math.abs(targetOffset - offset) < Math.abs(step)) offset = targetOffset;//non superare il target
      else offset += step;	  
	  
	  
	  if (frog.x <= 0) frog.x = 0;
	  if (frog.x >= 9) frog.x = 9;

      for (let [y,row] of segments) {
        //erbetta
		if (row.type === "grass") {
		  if (row.hasLake) {
		    if (!apple2Mode && !godMode && Math.abs(row.lake/tile - frog.x) < 0.5 && Math.round(y - offset) === 0) {
              alert('💀 Game Over!');
              isGameOver = true;
            }
		  }
		  //collisioni con falco
		  for (let f of row.cars) {
		    f.x += f.speed;
            if (f.speed>0 && f.x>canvas.width+tile) f.x=-tile;
            if (f.speed<0 && f.x<-tile) f.x=canvas.width+tile;
            const fy = f.y/tile;
			if (!godMode && Math.abs(f.x/tile - frog.x) < 0.5 && Math.round(fy - offset) === 0) {
              alert('💀 Game Over!');
              isGameOver = true;
            }
		  }
        }
		
		//fiume
		if (row.type === "river") {
		  let flagSave = godMode ? true : Math.round(y - offset) === 0 ? false : true;
		  for (let c of row.woods) {
		    c.x += c.speed;
			if (c.speed>0 && c.x>canvas.width+tile) c.x=-tile;
            if (c.speed<0 && c.x<-tile) c.x=canvas.width+tile;
			
		    const cy = c.y/tile;
			if (frog.x < 0 || frog.x > 9) flagSave = false;
			
			else if (Math.abs(c.x/tile - frog.x) < 0.5 && Math.round(y - offset) === 0) {
              flagSave = true;
			  frog.x = c.x/tile;
            }
		  }
		  if (!flagSave) {
		    alert('💀 Game Over!');
            isGameOver = true;
		  }
		}
		//strada
		if (row.type === "road") {
		  //collisioni con auto
          for (let c of row.cars) {
            c.x += c.speed;
            if (c.speed>0 && c.x>canvas.width+tile) c.x=-tile;
            if (c.speed<0 && c.x<-tile) c.x=canvas.width+tile;
            const cy = c.y/tile;
            if (!godMode && Math.abs(c.x/tile - frog.x) < 0.5 && Math.round(cy - offset) === 0) {
              alert('💀 Game Over!');
              isGameOver = true;
            }
          }
		}
      }
    }

    // --- Loop ---
    function draw() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const sortedRows = Array.from(segments.keys()).sort((a,b)=>a-b);
	  
	  for (let y of sortedRows) {
	  
	    const row = segments.get(y);
        
		//erba
		if (row.type === 'grass') {
          drawGrass(y, row);
		  for (let f of row.cars) drawFalcon(f);
		  continue;
        } 
		
		//fiume
		if (row.type === 'river') {
		  drawRiver(y, row);
		  for (let leaf of row.woods) drawLeaf(leaf);
		  continue;
		}
		
		//strada
		if (row.type === 'road') {
          //singola
		  if (row.lane === 0) {
            drawSingleRoad(y, row);
            for (let car of row.cars) drawCar(car);
			continue;
          } 
		  //1 di 2
		  if (row.lane === 1) {
            // Disegna la doppia carreggiata solo una volta
            drawRoadPair(y, y + 1, row);
            for (let car of row.cars) drawCar(car);

            // Disegna anche le auto della corsia inferiore (y+1)
            const lowerRow = segments.get(y + 1);
            if (lowerRow && lowerRow.cars) {
              for (let car of lowerRow.cars) drawCar(car);
            }
			continue;
          } 
		  
		  //2 di 2
		  if (row.lane === 2) {
            // Niente strada, solo auto (già disegnata sopra)
            continue;
          }
        }
      }
	  
      drawFrog();
	  
	  for (let s of signsToDraw) {
		if (s.type === "speed") drawSpeedLimitSign(s.x, s.y, 50);
		else if (s.type === "slow") drawSlowSign(s.x, s.y);
		else if (s.type === "cross") drawCrosswalkSign(s.x, s.y);
		else if (s.type === "noovertake") drawNoOvertakingSign(s.x, s.y);
		else if (s.type === "arrow") drawDirectionSign(s.x, s.y);
		else if (s.type === "nostop") drawNoStoppingSign(s.x, s.y);
		else if (s.type === "autovelox") drawAutoveloxColumn(s.x, s.y);
		else if (s.type === "trafficlight") drawTrafficLight(s.x, s.y);
		else if (s.type === "trafficlightbroken") drawTrafficLightBroken(s.x, s.y);
	  }
      signsToDraw = [];
	  
	  
      ctx.fillStyle = 'white';
      ctx.font = '10px sans-serif';
	  ctx.textAlign = 'left';
	  ctx.fillText('[A]pple2: '+ apple2Mode + ' - [G]od: ' + godMode + ' - [M]ute: ' + isMute + ' - [S]canLines: ' + scanLinesEnabled + ' - [B]/W: ' + bw + ' - [R]eset', 0, 10);
	  ctx.fillText('TargetOffset: ' + targetOffset, 0, 20);
      ctx.fillText('Offset: ' + offset, 0, 30);
      ctx.fillText('Frog: x=' + frog.x, 300, 20);
	  ctx.fillText('Frog: y=' + frog.y, 300, 30);
    }

    function loop(){
	  console.log('loop...');
	  if(!isGameOver) {
        update();
        draw();
	  }
      requestAnimationFrame(loop);
    }
    
	initRows();
	requestAnimationFrame(loop);



//apple2 forever
  function drawCricketeer(){
    const cx = frog.x * tile + tile / 2;
	const cy = canvas.height / 2 + tile / 2;

    ctx.fillStyle = COLORS.white;
	ctx.strokeStyle = COLORS.black;
	
	//codina
	ctx.beginPath();
	ctx.moveTo(cx - 2, cy + 6);
	ctx.lineTo(cx, cy + 12);
	ctx.lineTo(cx + 2, cy + 6);
	ctx.closePath();
	ctx.fill();
	ctx.stroke();
	
	//antenne
	ctx.moveTo(cx - 1, cy - 6);
	ctx.lineTo(cx - 4, cy - 10);
	ctx.moveTo(cx + 1, cy - 6);
	ctx.lineTo(cx + 4, cy - 10);
	ctx.stroke();
	
	//zampe sopra
	ctx.moveTo(cx - 3, cy - 1);
	ctx.lineTo(cx - 5, cy - 5);
	ctx.moveTo(cx + 3, cy - 1);
	ctx.lineTo(cx + 5, cy - 5);
	ctx.stroke();
	
	//zampe sotto
	ctx.moveTo(cx - 3, cy + 2);
	ctx.lineTo(cx - 5, cy + 6);
	ctx.lineTo(cx - 5, cy + 14);
	ctx.moveTo(cx + 3, cy + 2);
	ctx.lineTo(cx + 5, cy + 6);
	ctx.lineTo(cx + 5, cy + 14);
	ctx.stroke();
	
	//corpo
	ctx.beginPath();
	ctx.ellipse(cx, cy + 2, 3, 7, 0, 0, Math.PI * 2);
	ctx.closePath();
	ctx.fill();
	ctx.stroke();
	
}


//la rana pazza
  function drawFrog() {
	const cx = frog.x * tile;
    const cy = canvas.height / 2;
	
	if (apple2Mode) return drawCricketeer();
    
	ctx.save();
	ctx.translate(cx, cy + 2);  
    ctx.scale(tile / 100, tile / 100);	

    // Ombra sotto
    ctx.fillStyle = COLORS.shadowDark;
    ctx.beginPath();
    ctx.ellipse(50, 88, 38, 6, 0, 0, Math.PI * 2);
    ctx.fill();

    // Corpo verde
    ctx.beginPath();
    ctx.moveTo(18,30);
    ctx.bezierCurveTo(18,18,28,8,44,8);
    ctx.bezierCurveTo(60,8,70,18,82,30);
    ctx.bezierCurveTo(88,38,88,56,78,68);
    ctx.bezierCurveTo(68,82,32,82,22,68);
    ctx.bezierCurveTo(12,56,12,42,18,30);
    ctx.closePath();
    ctx.fillStyle = '#7fe04a';
    ctx.fill();
    ctx.lineWidth = 2.5;
    ctx.strokeStyle = '#126312';
    ctx.stroke();

    // Leggera ombra a sinistra
    const g = ctx.createLinearGradient(10,10,90,90);
    g.addColorStop(0, COLORS.shadowDark);
    g.addColorStop(1, COLORS.shadowNone);
    ctx.fillStyle = g;
    ctx.fill();

    // Pancia bianca
    ctx.beginPath();
    ctx.ellipse(50,48,30,28,0,0,Math.PI*2);
    ctx.fillStyle = COLORS.white;
    ctx.fill();

    // Ombra pancia
    ctx.beginPath();
    ctx.ellipse(50,55,20,12,0,0,Math.PI*2);
    ctx.fillStyle = COLORS.shadowLight;
    ctx.fill();

    // Riflesso verde
    ctx.beginPath();
    ctx.moveTo(62,20);
    ctx.quadraticCurveTo(45,18,40,28);
    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.stroke();

    // Occhi
    ctx.fillStyle = '#7fe04a';
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#126312';
    // Occhio sinistro
    ctx.beginPath();
    ctx.ellipse(35,18,14,12,0,0,Math.PI*2);
    ctx.fill(); ctx.stroke();
    // Occhio destro
    ctx.beginPath();
    ctx.ellipse(65,18,14,12,0,0,Math.PI*2);
    ctx.fill(); ctx.stroke();

    // Parte bianca occhi
    ctx.fillStyle = COLORS.white;
    ctx.beginPath();
    ctx.ellipse(35,18,9,7,0,0,Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(65,18,9,7,0,0,Math.PI*2);
    ctx.fill();

    // Pupille
    ctx.fillStyle = COLORS.black;
    ctx.beginPath(); ctx.ellipse(38,18,3.8,3.8,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(68,18,3.8,3.8,0,0,Math.PI*2); ctx.fill();

    // Riflessi occhi
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.beginPath(); ctx.arc(39.6,16.4,1.1,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(69.6,16.4,1.1,0,Math.PI*2); ctx.fill();

    // Narici
    ctx.fillStyle = '#126312';
    ctx.beginPath(); ctx.arc(49,26,1.6,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(55,26,1.6,0,Math.PI*2); ctx.fill();

    // Zampe anteriori
    ctx.fillStyle = '#68cd36';
    ctx.strokeStyle = '#126312';
    ctx.lineWidth = 2;

    // Zampa sinistra
    ctx.beginPath();
    ctx.moveTo(28,56);
    ctx.quadraticCurveTo(24,64,18,70);
    ctx.quadraticCurveTo(14,74,20,76);
    ctx.quadraticCurveTo(26,78,32,74);
    ctx.quadraticCurveTo(36,70,34,64);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Zampa destra
    ctx.beginPath();
    ctx.moveTo(72,56);
    ctx.quadraticCurveTo(76,64,82,70);
    ctx.quadraticCurveTo(86,74,80,76);
    ctx.quadraticCurveTo(74,78,68,74);
    ctx.quadraticCurveTo(64,70,66,64);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Dita stilizzate
    function drawToes(cx, cy, sign) {
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.quadraticCurveTo(cx + sign*6, cy+6, cx + sign*10, cy+10);
      ctx.moveTo(cx+sign*6, cy+2);
      ctx.quadraticCurveTo(cx+sign*10, cy+8, cx+sign*14, cy+12);
      ctx.stroke();
    }
    ctx.strokeStyle = '#0c5212';
    ctx.lineWidth = 1.6;
    drawToes(22,72,-1);
    drawToes(78,72,1);

    // Bocca
    ctx.strokeStyle = '#0b4b0f';
    ctx.lineWidth = 1.6;
    ctx.beginPath();
    ctx.moveTo(36,36);
    ctx.quadraticCurveTo(50,43,64,36);
    ctx.stroke();
	ctx.lineWidth = 1;

    ctx.restore();
  }
  

//resetta tutto
  function reset() {
	frog = { x: 5, y: 0 };
    segments = new Map();
	offset = 0;
	targetOffset = 0;
	signsToDraw = [];
	initRows();
	
	isGameOver = false;
  }
  
  
  function changeScanLines() {
    scanLinesEnabled = !scanLinesEnabled;
	if (scanLinesEnabled) {
		document.getElementById('scanlines-overlay').style.display = 'block';
	} else {
		document.getElementById('scanlines-overlay').style.display = 'none';
	}
  }
  
  function playSound(id, force = true) {
	  if (isMute) return;
	  const audio = document.getElementById(id);
	  if (!audio) return;//id non valido
	  if (!audio.paused && force) return;//gia in riproduzione
	  
	  //ok, riproducilo dall'inizio
	  audio.currentTime = 0;
      audio.play().catch((e) => {
	  console.warn("Errore riproduzione audio:", e);
	  });
	}

  })();
  </script>
</body>
</html>